}
## The following cacheSolve function returns the inverse of the "matrix" created
## with the above fuction. It first checks if the inverse has already been computed.
## If so, it gets the result and skips the computation. If not, it computes
## the inverse, sets the value in the cache via setinverse function.
## Computing the inverse of a square matrix can be done with the solve function in R.
## For example, if X is a square invertible matrix, then solve(X) returns its inverse.
## Note:This function assumes that the matrix is always invertible
## That means det(matrix)is not equal to
cacheSolve <- function(x, ...) {
Inv <- x$getinverse()
if(!is.null(Inv)) {
message("getting cached data.")
return(Inv)
}
data <- x$get()
Inv <- solve(data,...)
x$setinverse(Inv)
Inv
}
## Example of how above fuction works:
## First enter the square invertible matrix for which inverse need to be computed
## > X = matrix(
## + c(1, 0, 1, 2, 4, 0, 3, 5, 6),
## + nrow=3,
## + ncol=3)
## > X
##     [,1] [,2] [,3]
##[1,]    1    2    3
##[2,]    0    4    5
##[3,]    1    0    6
X = matrix(
c(1, 0, 1, 2, 4, 0, 3, 5, 6),
nrow=3,
ncol=3)
X
I = makeCacheMatrix(X)
I$get()
cacheSolve(I)
cacheSolve(I)
rm(list = ls())
## Matrix inversion is usually a costly computation and there may be
## some benefit to caching the inverse of a matrix rather than compute
##it repeatedly (there are also alternatives to matrix inversion that
##we will not discuss here). Your assignment is to write a pair of
##functions that cache the inverse of a matrix.
## This function creates a special "matrix" object that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(inverse) m <<- inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## This function computes the inverse of the special "matrix" returned
## by makeCacheMatrix above. If the inverse has already been calculated
## (and the matrix has not changed), then the cachesolve should retrieve
## the inverse from the cache.
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
X = matrix(
c(1, 0, 1, 2, 4, 0, 3, 5, 6),
nrow=3,
ncol=3)
I = makeCacheMatrix(X)
I$get()
cacheSolve(I)
cacheSolve(I)
cacheSolve(I)
rm(list = ls())
## These functions create a matrix that can cache its inverse and retrieve it.
+## 'makeCacheMatrix()', pretty much like 'makeVector()', assigns to 'x' in another
+## environment the value of the matrix (which is the argument for the function)
+## and to 'inv', also in another environment, the value of its inverse. It returns
+## a list with functions that give access or create such values, which can be used
+## through 'cacheSolve()'.
+
+makeCacheMatrix <- function(x = matrix()) {
+  inv<-NULL
+  set.matrix <- function(y){
+    x <<- y
+    inv <<- NULL
+  }
+  get.matrix <- function() x
+  set.inv <- function(solve) inv<<-solve
+  get.inv <- function() inv
+  list(set.matrix = set.matrix, get.matrix = get.matrix, set.inv = set.inv, get.inv = get.inv)
+}
+
+
+## cacheSolve needs as argument the value of 'makeCacheMatrix()' (i.e. not any matrix)
+## and assigns to its own 'inv' that makeCacheMatrix's 'inv'. If such value is
+## null (i.e., it was not computed before), it computes it, caches it and
+## returns it. If it was already cached, it returns it along with the message
+## "getting cached data".
+
+cacheSolve <- function(x, ...) {
+  inv <- x$get.inv()
+  if(!is.null(inv)){
+    message("getting cached data")
+    return(inv)
+  }
+  mat <- x$get.matrix()
+  inv <- solve(mat)
+  x$set.inv(inv)
+  inv
+   ## Return a matrix that is the inverse of 'x', being 'x' a matrix
+  ## resulting from 'makeCacheMatrix()'
+}
rm(list = ls())
## Begining of the Rprogramming assigment2
##Author:Amitrishit Contact email:aaammiitt@gmail.com
## The following two functions compute inverse of a given square matrix
## and catche it if computed before to avoid repeatation of expensive computation.
## makeCacheMatrix fuction does following:
## 1. set the value of the matrix
## 2. get the value of the matrix
## 3. set the value of inverse of the matrix
## 4. get the value of inverse of the matrix
## Note: "<<-" operator which can be used to assign a value to an object in an
## environment that is different from the current environment.
## Below are two functions that are used to create a special object
## that stores a matrix and caches its inverse.
makeCacheMatrix <- function(x = matrix()) {
Inv <- NULL
set <- function(y) {
x <<- y
Inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) Inv <<- inverse
getinverse <- function() Inv
list(set=set, get=get, setinverse=setinverse, getinverse=getinverse)
}
## The following cacheSolve function returns the inverse of the "matrix" created
## with the above fuction. It first checks if the inverse has already been computed.
## If so, it gets the result and skips the computation. If not, it computes
## the inverse, sets the value in the cache via setinverse function.
## Computing the inverse of a square matrix can be done with the solve function in R.
## For example, if X is a square invertible matrix, then solve(X) returns its inverse.
## Note:This function assumes that the matrix is always invertible
## That means det(matrix)is not equal to
cacheSolve <- function(x, ...) {
Inv <- x$getinverse()
if(!is.null(Inv)) {
message("getting cached data.")
return(Inv)
}
data <- x$get()
Inv <- solve(data,...)
x$setinverse(Inv)
Inv
}
## Example of how above fuction works:
## First enter the square invertible matrix for which inverse need to be computed
## > X = matrix(
## + c(1, 0, 1, 2, 4, 0, 3, 5, 6),
## + nrow=3,
## + ncol=3)
## > X
##     [,1] [,2] [,3]
##[1,]    1    2    3
##[2,]    0    4    5
##[3,]    1    0    6
## makeCacheMatrix: This function creates a special "matrix" object
## that can cache its inverse.
## I = makeCacheMatrix(X)
## > I$get()
## [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    0    4    5
## [3,]    1    0    6
## cacheSolve: This function computes the inverse of the special "matrix"
## returned by makeCacheMatrix above.
## > cacheSolve(I)
## [,1]        [,2]        [,3]
## [1,]  1.0909091 -0.54545455 -0.09090909
## [2,]  0.2272727  0.13636364 -0.22727273
## [3,] -0.1818182  0.09090909  0.18181818
## The inverse has already been calculated (and the matrix has not changed),
## then the cachesolve retrieves the inverse from the cache.
## > cacheSolve(I)
## getting cached data.
## [,1]        [,2]        [,3]
## [1,]  1.0909091 -0.54545455 -0.09090909
##[2,]  0.2272727  0.13636364 -0.22727273
## [3,] -0.1818182  0.09090909  0.18181818
## End of the Rprogramming assigment2
rm(list = ls())
## These functions create a matrix that can cache its inverse and retrieve it.
+## 'makeCacheMatrix()', pretty much like 'makeVector()', assigns to 'x' in another
+## environment the value of the matrix (which is the argument for the function)
+## and to 'inv', also in another environment, the value of its inverse. It returns
+## a list with functions that give access or create such values, which can be used
+## through 'cacheSolve()'.
+
+makeCacheMatrix <- function(x = matrix()) {
+  inv<-NULL
+  set.matrix <- function(y){
+    x <<- y
+    inv <<- NULL
+  }
+  get.matrix <- function() x
+  set.inv <- function(solve) inv<<-solve
+  get.inv <- function() inv
+  list(set.matrix = set.matrix, get.matrix = get.matrix, set.inv = set.inv, get.inv = get.inv)
+}
+
+
+## cacheSolve needs as argument the value of 'makeCacheMatrix()' (i.e. not any matrix)
+## and assigns to its own 'inv' that makeCacheMatrix's 'inv'. If such value is
+## null (i.e., it was not computed before), it computes it, caches it and
+## returns it. If it was already cached, it returns it along with the message
+## "getting cached data".
+
+cacheSolve <- function(x, ...) {
+  inv <- x$get.inv()
+  if(!is.null(inv)){
+    message("getting cached data")
+    return(inv)
+  }
+  mat <- x$get.matrix()
+  inv <- solve(mat)
+  x$set.inv(inv)
+  inv
+   ## Return a matrix that is the inverse of 'x', being 'x' a matrix
+  ## resulting from 'makeCacheMatrix()'
+}
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
## makeCacheMatrix creates a special "matrix", which is really a list containing a function to
## 1 set the value of the matrix
## 2 get the value of the matrix
## 3 set the value of the inverse
## 4 get the value of the inverse
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
## 'x' is created by makeCacheMatrix function.
m <- x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setsolve(m)
m
}
X
X = matrix(
c(1, 0, 1, 2, 4, 0, 3, 5, 6),
nrow=3,
ncol=3)
I = makeCacheMatrix(X)
cacheSolve(I)
cacheSolve(I)
rm(list = ls())
swirl()
mydf<-read.csv(path2csv,stringsAsFactors = FALSE)
dim(mydf)
head(mydf)
library(dplyr)
packageVersion("dplyr")
cran <- tbl_df(mydf)
rm("mydf")
cran
?select
select(cran, ip_id, package, country)
5:20
select(cran,
r_arch:country)
select(cran,country:r_arch)
cran
select(cran, -time)
-5:20
-(5:20)
select(cran, -(X:size))
filter(cran, package == "swirl")
filter(cran, r_version == "3.1.1", country == "US")
?Comparison
filter(cran, r_version <= "3.0.2", country == "IN")
filter(cran, country == "US" | country == "IN")
filter(cran, size > 100500 & r_os == "linux-gnu")
filter(cran, size > 100500,  r_os == "linux-gnu")
is.na(c(3, 5, NA, 10))
!is.na(c(3, 5, NA, 10))
filter(cran, r_version, !is.na())
filter(cran, r_version, !is.na(r_version))
filter(cran, r_version, !is.na("r_version"))
filter(cran, !is.na(r_version))
cran2<-select(cran,size:ip_id)
arrange(cran2, ip_id)
arrange(cran2, desc(ip_id))
arrange(cran2, package, ip_id)
arrange(cran2, country, desc(r_version), ip_id)
cran3<-select(cran,ip_id,package,size)
crane3
cran3
mutate(cran3, size_mb = size / 2^20)
mutate(cran3, size_gb = size_mb / 2^10)
crane3
cran3
mutate(cran3, size_mb = size / 2^20, size_gb = size_mb / 2^10)
mutate(cran3, correct size = size +1000 )
mutate(cran3, correct_size = size +1000 )
summarize(cran,avg_bytes = mean(size))
mutate(cran3, size_mb = size / 2^20)
?download.file
download.file(https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv,mcdata.csv)
download.file("https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv",mcdata.csv)
download.file("https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv","mcdata.csv")
inputfile = read.csv("mcdata.csv")
class(inputfile)
head(inputfile)
summary(inputfile)
week3 <- tbl_df(inpufile)
week3 <- tbl_df(inputfile)
week3
x<-select(week3, ACR, AGS)
x
y<-filter(x, ACR, AGS, !is.na())
y<-filter(x, ACR,!is.na())
filter(week3, ACR, !is.na("ACR"))
y<-filter(x, ACR, !is.na("ACR"))
y
z<-filter(x, AGS, !is.na("AGS"))
z
a<-filter(z, ACR == 3)
a
b<-filter(a, AGS == 6)
b
x<-select(week3, ACR, AGS,SERIALNO)
x
y<-filter(x, ACR, AGS, !is.na("ACR","AGS"))
y<-filter(x, ACR, !is.na("ACR"))
z<-filter(y, AGS, !is.na("AGS"))
z
a<-filter(z, ACR == 3)
a
b<-filter(a, AGS == 6)
b
c<-arrange(b, SERIALNO)
c
x
week3
filter(week3, SERIALNO == 30346)
getwd()
install.pacages(jpeg)
install.packages("jpeg")
library(jpeg)
pic <-  readJpeg(getURLContent("https://d396qusza40orc.cloudfront.net/getdata%2Fjeff.jpg"))
?readJpeg
?read.Jpeg
readJPEG("https://d396qusza40orc.cloudfront.net/getdata%2Fjeff.jpg", native = TRUE)
download.file("https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv",mcdata.jpg)
download.file("https://d396qusza40orc.cloudfront.net/getdata%2Fjeff.jpg",mcdata.jpg)
download.file("http://d396qusza40orc.cloudfront.net/getdata%2Fjeff.jpg",mcdata.jpg)
readJPEG("http://d396qusza40orc.cloudfront.net/getdata%2Fjeff.jpg", native = TRUE)
readJPEG("https://d396qusza40orc.cloudfront.net/getdata%2Fjeff.jpg", native = TRUE)
quit()
str(str)
set.seed(1)
rpois(5, 2)
library(datasets)
Rprof()
fit <- lm(y ~ x1 + x2)
Rprof(NULL)
$by.total
getwd()
wd<-getwd()
wd
setwd(wd)
newd<-"project"
newd
wd<-getwd()
newd<-"project"
dir.create(file.path(wd, newd))
setwd(file.path(wd, newd))
getwd()
library(httr) 
url <- "https://d396qusza40orc.cloudfront.net/getdata%2Fprojectfiles%2FUCI%20HAR%20Dataset.zip"
file <- "project_data.zip"
if(!file.exists(file)){
print("file already exist")
download.file(url, file, method="curl")
}
file
if(!file.exists(file)){
print("file already exist")
download.file(url, file)
}
if(!file.exists(file)){
print("file already exist")
download.file(url, file)
}
if(!file.exists(file)){
print("downloading the file")
download.file(url, file)
} else {
print("file already exist")
}
foldername<- "UCI HAR Dataset"
resultsfoldername <- "results"
if(!file.exists(foldername)){
print("unzip file")
unzip(file, list = FALSE, overwrite = TRUE)
} else {
print("folder already exist")
}
if(!file.exists(resultsfoldername)){
print("create results folder")
dir.create(resultsfoldername)
} else {
print("folder already exist")
}
gettables <- function (filename,cols = NULL){
print(paste("Getting table:", filename))
f <- paste(foldername,filename,sep="/")
data <- data.frame()
if(is.null(cols)){
data <- read.table(f,sep="",stringsAsFactors=F)
} else {
data <- read.table(f,sep="",stringsAsFactors=F, col.names= cols)
}
data
}
gettables <- function (filename,cols = NULL){
print(paste("Getting table:", filename))
f <- paste(foldername,filename,sep="/")
data <- data.frame()
if(is.null(cols)){
data <- read.table(f,sep="",stringsAsFactors=F)
} else {
data <- read.table(f,sep="",stringsAsFactors=F, col.names= cols)
}
data
}
gettables <- function (filename,cols = NULL){
print(paste("Getting table:", filename))
f <- paste(foldername,filename,sep="/")
data <- data.frame()
if(is.null(cols)){
data <- read.table(f,sep="",stringsAsFactors=F)
} else {
data <- read.table(f,sep="",stringsAsFactors=F, col.names= cols)
}
data
}
gettables <- function (filename,cols = NULL){
print(paste("Getting table:", filename))
f <- paste(foldername,filename,sep="/")
data <- data.frame()
if(is.null(cols)){
data <- read.table(f,sep="",stringsAsFactors=F)
} else {
data <- read.table(f,sep="",stringsAsFactors=F, col.names= cols)
}
data
}
gettables <- function (filename,cols = NULL){
print(paste("Getting table:", filename))
f <- paste(foldername,filename,sep="/")
data <- data.frame()
if(is.null(cols)){
data <- read.table(f,sep="",stringsAsFactors=F)
} else {
data <- read.table(f,sep="",stringsAsFactors=F, col.names= cols)
}
data
}
gettables <- function (filename,cols = NULL){
print(paste("Getting table:", filename))
f <- paste(foldername,filename,sep="/")
data <- data.frame()
if(is.null(cols)){
data <- read.table(f,sep="",stringsAsFactors=F)
} else {
data <- read.table(f,sep="",stringsAsFactors=F, col.names= cols)
}
data
}
q()
